# Java 基础

### 其他

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038176352-2fde8b60-55a7-41b3-a129-2493babb72c5.png#clientId=ub01b8327-a2bc-4&from=paste&height=505&id=uc1cc8a0b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1009&originWidth=1475&originalType=binary&ratio=1&size=616333&status=done&style=none&taskId=u0eaa2467-9538-4e63-af94-796b964fee1&width=737.5)；

##### 面向对象

封装，继承，多态

编译期叫做静态绑定。运行期叫做动态绑定。

向上转型，向下转型

##### JDK，JRE，JVM，字节码

JDK = JRE + Java 工具
JRE = JVM + lib 类库

字节码：1 跨平台，2 解决了传统解释性语言执行效率低的问题

##### Java，C++

多继承，指针，内存管理

##### ==，equals，hashCode

互推的关系
equals 重写，hashCode 也要重写

##### 重载，重写

位置，修饰符 + 返回值 + 方法名 + 参数 + 异常

##### final，static

类：不可继承，方法：不可覆盖，变量：不可改变

static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，
static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。

##### String，StringBuffer，StringBuilder

不可变，安全，不安全

##### 反射

优点：灵活可拓展，便于使用测试工具

缺点：性能更差，需要没有安全限制的环境，打破封装使内部暴露

##### 动态代理

动态：在程序执行时，调用 jdk 提供的方法才能创建代理类的对象。
代理：创建的是代理类的对象

基于反射

jdk 动态代理：必须有接口，目标类必须实现接口
cglib 动态代理：类可继承

功能增强
减少代码的重复
专注业务逻辑代码
解耦合，让你的业务功能和日志，事务等分离

应用场景：框架

##### Object

hashCode，equals，toString，wait，notify
clone，finalize

```
public native int hashCode()
public boolean equals(Object obj)
protected native Object clone() throws CloneNotSupportedException
public String toString()
public final native Class<?> getClass()
protected void finalize() throws Throwable {}
public final native void notify()
public final native void notifyAll()
public final native void wait(long timeout) throws InterruptedException
public final void wait(long timeout, int nanos) throws InterruptedException
public final void wait() throws InterruptedException
```

##### 访问权限

public > protected > 默认 > private

属性，方法：4 个都能用
类，接口：public 和默认能用，其它不行

| 访问控制修饰符 | 本类 | 同包 | 子类 | 任意位置 |
| --- | --- | --- | --- | --- |
| public | √ | √ | √ | √ |
| protected | √ | √ | √ | × |
| 默认 | √ | √ | × | × |
| private | √ | × | × | × |


##### BIO，NIO，AIO

[小专栏](https://xiaozhuanlan.com/topic/4973615028)；

BIO (Blocking I/O)

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038188007-e820d894-0c53-46fc-9bc9-9ff9ea20c662.png#clientId=ub01b8327-a2bc-4&from=paste&height=392&id=u38ea3d8c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=783&originWidth=734&originalType=binary&ratio=1&size=108356&status=done&style=none&taskId=ue2a0e8a8-9dec-44e1-8340-7914560cabb&width=367)；
数据的读取写入必须阻塞在一个线程内等待其完成。（无法处理大量连接）

NIO (Non-blocking/New I/O)

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038193551-d012529a-de00-46f1-b9ba-afd521921c58.png#clientId=ub01b8327-a2bc-4&from=paste&height=376&id=u504f4cb1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=751&originWidth=771&originalType=binary&ratio=1&size=83343&status=done&style=none&taskId=u5b4f309c-0b8f-4b63-9f6f-3f540bbb9b7&width=385.5)；![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038196362-56ecbc8d-f074-437d-b8c6-fee91123e3f1.png#clientId=ub01b8327-a2bc-4&from=paste&height=412&id=ua8918c9a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=823&originWidth=763&originalType=binary&ratio=1&size=156260&status=done&style=none&taskId=u760b3c36-67ca-4c43-bd60-d9f87cc8997&width=381.5)；

AIO (Asynchronous I/O)

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038201892-c3460c8f-964f-4671-a89c-d8d0c3a087e2.png#clientId=ub01b8327-a2bc-4&from=paste&height=403&id=uf8ef89d4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=805&originWidth=730&originalType=binary&ratio=1&size=94441&status=done&style=none&taskId=u28711640-d9fb-4c5e-80f5-a985a577439&width=365)；
异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

##### 接口，抽象类

抽象类：方法可以实现，属性类型多样，单继承
接口：行为（功能）

is a，like a

接口没有构造方法

##### Comparable 和 Comparator

Comparable：比较规则不会发生改变的时候，或者说当比较规则只有 1 个的时候（直接实现接口）
Comparator：比较规则有多个，且需要多个比较规则之间频繁切换（构造集合时传入，构造器类要继承接口）

##### 异常

- Throwable 
   - Exception 
      - RunTimeException（导致程序当前线程执行失败）
NullPointException，ClassCastException
      - CheckedException（try catch）
   - Error
StackOverflowError

##### 开发原则（S.O.L.I.D）

1. 单一责任原则（SRP）
2. 开放封闭原则（OCP）
3. 里氏替换原则（LSP）
4. 接口分离原则（ISP）
5. 依赖倒置原则（DIP）
高层模块不应该依赖于低层模块，二者都应该依赖于抽象；
高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响高层模块，从而迫使高层模块也需要改动。

##### ？？？设计模式

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038209449-95113960-aa0d-4e00-857e-33b105aa0e6a.png#clientId=ub01b8327-a2bc-4&from=paste&height=540&id=u32b3925f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1445&originalType=binary&ratio=1&size=440293&status=done&style=none&taskId=ub15681f0-8f8e-4cbe-8bfd-d70eafbc1c4&width=722.5)；

单例：[单例](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%20-%20%E5%8D%95%E4%BE%8B.md)；

```
懒汉（不安全）
public class Singleton {
    private static Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}

懒汉（安全）
public static synchronized Singleton getUniqueInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
}

饿汉
private static Singleton uniqueInstance = new Singleton();

双重校验锁
public class Singleton {
    private volatile static Singleton uniqueInstance;
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
    }
}

静态内部类
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton() {
    }
    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

工厂：[简单工厂](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.md)；[工厂方法](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.md)；[抽象工厂](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.md)；

```
简单工厂
public interface Product {
}
public class ConcreteProduct implements Product {
}
public class ConcreteProduct1 implements Product {
}
public class ConcreteProduct2 implements Product {
}

public class SimpleFactory {
    public Product createProduct(int type) {
        if (type == 1) {
            return new ConcreteProduct1();
        } else if (type == 2) {
            return new ConcreteProduct2();
        }
        return new ConcreteProduct();
    }
}

public class Client {
    public static void main(String[] args) {
        SimpleFactory simpleFactory = new SimpleFactory();
        Product product = simpleFactory.createProduct(1);
        // do something with the product
    }
}
```

```
工厂方法
public abstract class Factory {
    abstract public Product factoryMethod();
    public void doSomething() {
        Product product = factoryMethod();
        // do something with the product
    }
}

public class ConcreteFactory extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct();
    }
}
public class ConcreteFactory1 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct1();
    }

}
public class ConcreteFactory2 extends Factory {
    public Product factoryMethod() {
        return new ConcreteProduct2();
    }
}
```

```
抽象工厂
public class AbstractProductA {
}
public class AbstractProductB {
}
public class ProductA1 extends AbstractProductA {
}
public class ProductA2 extends AbstractProductA {
}
public class ProductB1 extends AbstractProductB {
}
public class ProductB2 extends AbstractProductB {
}

public abstract class AbstractFactory {
    abstract AbstractProductA createProductA();
    abstract AbstractProductB createProductB();

}
public class ConcreteFactory1 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA1();
    }
    AbstractProductB createProductB() {
        return new ProductB1();
    }
}
public class ConcreteFactory2 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA2();
    }
    AbstractProductB createProductB() {
        return new ProductB2();
    }
}

public class Client {
    public static void main(String[] args) {
        AbstractFactory abstractFactory = new ConcreteFactory1();
        AbstractProductA productA = abstractFactory.createProductA();
        AbstractProductB productB = abstractFactory.createProductB();
        // do something with productA and productB
    }
}
```

迭代器：[迭代器](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%BF%AD%E4%BB%A3%E5%99%A8.md)，提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。

观察者：[观察者](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%A7%82%E5%AF%9F%E8%80%85.md)，定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。

适配器：[适配器](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E9%80%82%E9%85%8D%E5%99%A8.md)，把一个类接口转换成另一个用户需要的接口。（鸭子冒充火鸡）

代理：[代理](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E4%BB%A3%E7%90%86.md)，控制对其它对象的访问。（远程代理，虚拟代理，保护代理，智能代理）

装饰：[装饰](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%A3%85%E9%A5%B0.md)，为对象动态添加功能。（不同饮料 + 不同调料）

模板方法：[模板方法](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.md)，定义算法框架，并将一些步骤的实现延迟到子类。通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。（不同豆浆，使用不同原料）

策略：[策略](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AD%96%E7%95%A5.md)，定义一系列算法，封装每个算法，并使它们可以互换。（不同鸭子，飞）

##### Servlet

用来处理客户端请求并产生动态网页内容的 Java 类，多线程可以并行的为多个请求服务。

第一次请求时创建，只会创建一个，HTTP 服务器关闭时销毁

ServletRequest 类可以找出客户端机器的 IP 地址或者是主机名。
getRemoteAddr()方法获取客户端主机的 IP 地址，getRemoteHost()可以获取主机名。

##### JSP

一种混合了静态内容和动态产生的内容的技术。

1. 浏览器发起 JSP 请求
2. Http 服务器将 JSP 文件内容【编辑】为一个 Servlet **接口实现类** （.java）
3. Http 服务器将 Servlet 接口实现类【编译】为 **class 文件** (.class)
4. Http 服务器负责创建这个 class 的**实例对象** ，这个实例对象就是 Servlet 实例对象
5. Http 服务器通过 Servlet 实例对象**调用_jspService 方法**，将 jsp 文件内容写入到响应体

优点：
JSP 页面是被动态编译成 Servlet 的，因此，开发者可以很容易的更新展现代码。
JSP 页面可以被预编译。
JSP 页面可以很容易的和静态模板结合。
开发者可以提供让页面设计者以类 XML 格式来访问的自定义的 JSP 标签库。

### 集合

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038219428-301a8d6c-9a3f-41e7-9b7c-f17ff35db69b.png#clientId=ub01b8327-a2bc-4&from=paste&height=366&id=ua1d342d3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=731&originWidth=1100&originalType=binary&ratio=1&size=77446&status=done&style=none&taskId=u69719d5d-4eec-4ca6-86c6-b527596cad9&width=550)；

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038221652-18f2b83a-ee91-42be-b874-82ecd8c24b30.png#clientId=ub01b8327-a2bc-4&from=paste&height=386&id=ua2fc6053&margin=%5Bobject%20Object%5D&name=image.png&originHeight=771&originWidth=1035&originalType=binary&ratio=1&size=64811&status=done&style=none&taskId=u817549a8-edf2-4941-905a-68a16d506a3&width=517.5)；

##### List，Set，Queue，Map

Set：无序不可重复，允许单个 null，遍历：迭代器，for each

- TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
- HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
- LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。

List：有序可重复，允许多个 null，遍历：迭代器，get

- ArrayList：基于动态数组实现，支持随机访问。
- Vector：和 ArrayList 类似，但它是线程安全的。
- LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。

Queue

- LinkedList：可以用它来实现双向队列。
- PriorityQueue：基于堆结构实现，可以用它来实现优先队列。

Map：使用键值对（key-value）存储，Key 是无序的、不可重复的，value 是无序的、可重复的

- TreeMap：基于红黑树实现。
- HashMap：基于哈希表实现。链表高度到 8，数组长度超过 64，链表转换为红黑树，到 6 转换回去
- HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全
- ConcurrentHashMap 的效率会更高，因为使用了分段锁，只锁住 hash 值相同的（JDK1.7）
- LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。

##### 使用选择

需要根据键值获取到元素值时就选用 `Map` 接口下的集合，
需要排序时选择 `TreeMap`,
不需要排序时就选择 `HashMap`,需要保证线程安全就选用 `ConcurrentHashMap`。

当我们只需要存放元素值时，就选择实现 `Collection` 接口的集合，
需要保证元素唯一时选择实现 `Set` 接口的集合比如 `TreeSet` 或 `HashSet`，
不需要就选择实现 `List` 接口的比如 `ArrayList` 或 `LinkedList`，

##### 快速失败(fail-fast)和安全失败(fail-safe)

一：快速失败（fail—fast）（java.util 包下的集合类）

迭代器遍历集合过程中，对集合结构进行了修改（增加、删除），则会抛出 Concurrent Modification Exception。（根据 modCount 判断，类似版本号）

二：安全失败（fail—safe）（java.util.concurrent 包下的集合类）

遍历时不是直接在集合内容上访问的，先复制，再遍历复制的内容。

缺点：迭代器并不能访问到修改后的内容

##### 数组(Array)和列表(ArrayList)

Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。
Array 大小是固定的，ArrayList 的大小是动态变化的。
ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。

##### Iterator 和 ListIterator

Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。
Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。
ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

### JVM

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038227104-e32bccc7-94b3-4a65-ae40-1fbab68f1264.png#clientId=ub01b8327-a2bc-4&from=paste&height=326&id=u92450c3a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=694&originalType=binary&ratio=1&size=90770&status=done&style=none&taskId=u4bd4cd39-c199-4ee9-b526-f499ee0e157&width=347)；

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038230064-7fdc1242-b71a-47dc-ba93-dd4aa793206c.png#clientId=ub01b8327-a2bc-4&from=paste&height=326&id=u859e8f99&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=754&originalType=binary&ratio=1&size=101199&status=done&style=none&taskId=ubef85b9f-86b0-43bb-976b-67841afef69&width=377)；

##### 运行时数据区域（1.7 后，方法区 >> 元空间）

程序计数器（正在执行的虚拟机字节码指令的地址）
Java 虚拟机栈（局部变量表、操作数栈、常量池引用等）
本地方法栈（服务本地方法，一般是用其它语言编写的）

堆（逃逸分析）（新生代，老年代）（字符串常量池）

方法区（永久代）（已被加载的类信息、常量、静态变量、即时编译器编译后的代码）（运行时常量池）

##### 为什么要用元空间

原方法区有大小限制，元空间能加载更多类

##### ？？？对象创建过程

1.  类加载 
2.  分配内存 
3.  初始化零值 
4.  设置对象头 
5.  执行 init 方法 
6.  加载 
   1. 通过全类名获取定义此类的二进制字节流
   1. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
   1. 在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口
7.  验证
确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 
8.  准备
类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。
实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。 
9.  解析
将常量池的符号引用替换为直接引用的过程。
其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 
10.  初始化
初始化阶段才真正开始执行类中定义的 Java 程序代码。
在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 

##### 类加载器，双亲委派

加载器

启动类加载器：Bootstrap ClassLoader：%JAVA_HOME%lib 下的 jar 包和 class 文件
扩展类加载器：ExtClassLoader：%JAVA_HOME%/lib/ext 文件夹下的 jar 包和 class 类
应用程序类加载器：AppClassLoader：加载 classpath 下的类文件。系统类加载器，默认的线程上下文加载器

双亲委派

向上委派：向上查找各加载器的**缓存**中是否已加载（到最顶层加载器）
向下查找：向下去各自路径中查找，并加载，然后返回（到发起的加载器为止）

安全性，防止替换核心类
避免了类的重复加载（同一个类加载，才算同一个类）

##### GC 判断对象可以被回收

-  引用计数法（循环引用）（效率高） 
-  可达性分析法：GC Roots 
   - 虚拟机栈，本地方法栈中引用的对象
方法区中类静态属性，常量引用的对象
   - 第一次是经过可达性分析发现没有与 GC Roots 相连接的引用链
第二次是在由虚拟机自动建立的 Finalizer 队列中判断是否需要执行 finalize()方法
-  类卸载 
-  常量池回收 

System.gc()和 Runtime.gc()：提示 JVM 要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于 JVM 的。

##### 强弱软虚引用

```java
// 强引用
Object obj = new Object();
// 弱引用：一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前
WeakReference<Object> wf = new WeakReference<Object>(obj);
// 软引用：只有在内存不够的情况下才会被回收。
SoftReference<Object> sf = new SoftReference<Object>(obj);
// 一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。
// 为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
```

##### 垃圾收集算法

标记清除
标记整理
复制算法：大小相同两块
分代收集：根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。
（新生代使用：复制算法；老年代使用：标记 - 清除 或者 标记 - 整理 算法）

##### ？？？垃圾收集器

### 线程、并发

##### 进程，线程

线程 是 进程 划分成的更小的运行单位。

基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。

执行（切换）开销

资源的管理（分配）和保护（共享，通信）

多线程 OS 中，进程不是一个可执行的实体。

##### 线程生命周期，线程状态

创建，就绪（调用 start 后），运行，阻塞，死亡

等待阻塞：wait，不能自动唤醒，notify，notifyall
同步阻塞：同步锁
其他阻塞：sleep，join，IO

##### 死锁，条件，预防，避免，检测，解除

**条件**

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
3. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
4. 循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。

**预防**

**破坏互斥条件**：例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

**破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

**破坏请求与保持条件**：一次性申请所有的资源。

**破坏循环等待条件**靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

**避免**

安全状态

银行家算法

**检测**

**每种类型一个资源的死锁检测**：通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。
**每种类型多个资源的死锁检测**：
E 向量：资源总量
A 向量：资源剩余量
C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
R 矩阵：每个进程请求的资源数量

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038243935-eaaa274e-f170-4932-9c73-dc9ce9e289e2.png#clientId=ub01b8327-a2bc-4&from=paste&height=125&id=uc1a5f102&margin=%5Bobject%20Object%5D&name=image.png&originHeight=249&originWidth=483&originalType=binary&ratio=1&size=53987&status=done&style=none&taskId=ue6ecbb38-e976-4216-8353-df7b2a42be3&width=241.5)

具体算法：每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 Pi ，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
3. 如果没有这样一个进程，算法终止。（死锁）

**解除**

资源剥夺法：挂起死锁进程，释放死锁进程的资源，给其他进程使用

撤销进程法：强制撤销部分甚至全部死锁进程并剥夺其资源

进程回退法：让一个或多个进程回退到足以避免死锁的地步

##### sleep()、wait()、join()合并、yield()让位，锁池、等待池

锁池（拿到锁后才能进入就绪队列等待 cpu 资源）
等待池（调用 wait 后放入等待池）（notify：随机一个，等待池 >> 锁池）

1、sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。
2、sleep 方法不会释放 lock，但是 wait 会释放，而且会加入到等待队列中。
3、sleep 方法不依赖于同步器 synchronized，但是 wait 需要依赖 synchronized 关键字。
4、sleep 不需要被唤醒（休眠之后推出阻塞），但是 wait 需要（不指定时间需要被别人中断）。
5、sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。
6、sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 后可能还是有机会重新竞争到锁继续执行的。

yield()执行后线程直接进入就绪状态，马上释放了 cpu 的执行权，但是依然保留了 cpu 的执行资格，所以有可能 cpu 下次进行线程调度还会让这个线程获取到执行权继续执行
join()执行后线程进入阻塞状态，例如在线程 B 中调用线程 A 的 join()，那线程 B 会进入到阻塞队列，直到线程 A 结束或中断线程

##### ？？？Thread，Runable，Callable

（都可以用来创建（实现）线程）

Thread 和 Runnable 的实质是继承关系，没有可比性。

实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。

无论使用 Runnable 还是 Thread，都会 new Thread，然后执行 run 方法。

用法上

如果有复杂的线程操作需求，那就选择继承 Thread，如果只是简单的执行一个任务，那就实现 runnable。

如果想让线程池执行任务的话需要实现的 Runnable 接口或 Callable 接口。
两者的区别在于 Runnable 接口不会返回结果但是 Callable 接口可以返回结果。

Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；

类可能只要求可执行就行，继承整个 Thread 类开销过大。

execute() 方法（用于提交不需要返回值的任务）
submit() 方法（用于提交需要返回值的任务）

start：启动一个分支线程，在 JVM 中开辟一个新的栈空间，这段代码任务完成之后就结束了 run：start 启动成功的线程会自动调用 run 方法，并且 run 方法在分支栈的栈底部，main 方法在主栈的栈底部（run 和 main 是平级的）

##### 守护线程

GC
守护线程中创建的线程也是守护线程
线程池会自动将守护线程转换为用户线程

##### ？？？25 ThreadLocal

每一个 Thread 对象均含有一个 ThreadLocalMap 类型的成员变量 threadLocals ，它存储本线程中所有 ThreadLocal 对象及其对应的值
ThreadLocalMap 由一个个 Entry 对象构成
Entry 继承自 WeakReference<ThreadLocal<?>> ，一个 Entry 由 ThreadLocal 对象和 Object 构成。由此可见， Entry 的 key 是 ThreadLocal 对象，并且是一个弱引用。当没指向 key 的强引用后，该 key 就会被垃圾收集器回收
当执行 set 方法时，ThreadLocal 首先会获取当前线程对象，然后获取当前线程的 ThreadLocalMap 对象。再以当前 ThreadLocal 对象为 key，将值存储进 ThreadLocalMap 对象中。
get 方法执行过程类似。ThreadLocal 首先会获取当前线程对象，然后获取当前线程的 ThreadLocalMap 对象。再以当前 ThreadLocal 对象为 key，获取对应的 value。
由于每一条线程均含有各自私有的 ThreadLocalMap 容器，这些容器相互独立互不影响，因此不会存在线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。
使用场景：
1、在进行对象跨层传递的时候，使用 ThreadLocal 可以避免多次传递，打破层次间的约束。
2、线程间数据隔离
3、进行事务操作，用于存储线程事务信息。
4、数据库连接，Session 会话管理。

Spring 框架在事务开始时会给当前线程绑定一个 Jdbc Connection,在整个事务过程都是使用该线程绑定的 connection 来执行数据库操作，实现了事务的隔离性。Spring 框架里面就是用的 ThreadLocal 来实现这种隔离

##### ？？？26 ThreadLocal 内存泄漏

##### 并发、并行、串行

##### ？？？并发三大特性（内存模型）

[cs](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%8D%81java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)；

原子性（事务原子性）
可见性（事务脏读）（总线锁定， MESI 缓存一致性）
有序性

##### ？？？volatile，synchronized，锁

[volatile](https://xiaozhuanlan.com/topic/2419358670#section2volatile)；

##### 线程池，线程池参数，复用原理，阻塞队列

降低资源消耗
提高响应速度
提高线程的可管理性

corePoolSize 代表核心线程数
maxinumPoolSize 代表的是最大线程数
keepAliveTime 、unit 表示超出核心线程数之外的线程的空闲存活时间，unit 时间单位
workQueue 用来存放待执行的任务
ThreadFactory 是一个线程工厂，用来生产线程执行任务。
Handler 任务拒绝策略，有两种情况，第一种是当我们调用 shutdown 等方法关闭线程池后，再提交任务就会遭到拒绝。另一种情况就是当达到最大线程数。

线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过 Thread 创建线程时的
一个线程必须对应一个任务的限制。
线程池对 Thread 进行了封装，让每个线程去执行一个“循环任务”，在这个“循环任务”中不停检查是否有任务需要被执行，如果有则调用任务中的 run 方法，将 run 方法当成一个普通的方法执行。

阻塞队列：任务队列中没有任务时，阻塞获取任务的线程，使得线程进入 wait 状态，释放 cpu 资源。

四种拒绝策略：

CallerRunsPolicy - 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大

AbortPolicy - 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。

DiscardPolicy - 直接丢弃，其他啥都没有

DiscardOldestPolicy -  当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入

##### 线程池处理流程

依次判断：核心线程，任务队列，最大线程

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038255548-c25bc2ae-b0b5-4236-889d-45330354a16b.png#clientId=ub01b8327-a2bc-4&from=paste&height=384&id=ufce83983&margin=%5Bobject%20Object%5D&name=image.png&originHeight=768&originWidth=603&originalType=binary&ratio=1&size=88412&status=done&style=none&taskId=u209f6b5d-9392-4f1b-8a79-b0bb9714520&width=301.5)；

# 框架

### Spring

##### ？？？14 如何实现 IOC 容器

1、配置文件配置包扫描路径
2、递归包扫描获取.class 文件
3、反射、确定需要交给 IOC 管理的类
4、对需要注入的类进行依赖注入

配置文件中指定需要扫描的包路径
定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注解
从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路径下所有以.class 结尾的文件添加到一个 Set 集合中进行存储
遍历这个 set 集合，获取在类上有指定注解的类，并将其交给 IOC 容器，定义一个安全的 Map 用来存储这些对象
遍历这个 IOC 容器，获取到每一个类的实例，判断里面是有有依赖其他的类的实例，然后进行递归注入

##### Spring 是什么

轻量级容器框架，用来装 javabean（java 对象），控制反转（IoC）和面向切面（AOP）
中间层框架（万能胶），起连接作用

##### AOP

面向切面编程，基于动态代理
将程序的交叉业务逻辑（比如日志，事务等），封装成切面（切面：给目标对象增加的功能），注入到目标对象（具体业务逻辑）中

Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。

##### IoC，DI

容器，控制反转，依赖注入

ioc 容器：实际上就是个 map（key，value），里面存的是各种对象（在 xml 里配置的 bean 节点、@repository、@service、@controller、@component），在项目启动的时候会读取配置文件里面的 bean 节点，根据全限定类名使用反射创建对象放到 map 里、扫描到打上上述注解的类还是通过反射创建对象放到 map 里。
这个时候 map 里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过 DI 注入（autowired、resource 等注解，xml 里 bean 节点内的 ref 属性，项目启动的时候会读取 xml 节点 ref 属性根据 id 注入，也会扫描这些注解，根据类型或 id 注入；id 就是对象名）。

控制反转：对象 A 获得依赖对象 B 的过程，由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。

依赖注入：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由 IOC 容器主动注入。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式是依赖注入。应用广泛。

目的：减少对代码的改动，也能实现不同的功能。实现解耦合。

##### ？？？BeanFactory，ApplicationContext

ApplicationContext 是 BeanFactory 的子接口，提供了更完整的功能：
① 继承 MessageSource，因此支持国际化。
② 统一的资源文件访问方式。
③ 提供在监听器中注册 bean 的事件。
④ 同时加载多个配置文件。
⑤ 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层。

BeanFactroy 采用的是延迟加载形式来注入 Bean 的，ApplicationContext 在容器启动时一次性创建所有的 Bean（占用内存空间。当应用程序配置 Bean 较多时，程序启动较慢）
BeanFactory 通常以编程的方式被创建，ApplicationContext 还能以声明的方式创建，如使用 ContextLoader。
BeanFactory 和 ApplicationContext 都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但两者之间的区别是：BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册。

##### Spring Bean 生命周期

1、解析类得到 BeanDefinition
2、推断构造方法，并进行实例化得到一个对象
4、对加了 [@Autowired ](/Autowired ) 等注解的属性进行属性填充 
5、回调 Aware 方法，比如 BeanNameAware，BeanFactoryAware
6、调用 BeanPostProcessor 的初始化前的方法
7、调用初始化方法
8、调用 BeanPostProcessor 的初始化后的方法，在这里会进行 AOP
9、如果当前创建的 bean 是单例的则会把 bean 放入单例池
10、使用 bean
11、Spring 容器关闭时调用 DisposableBean 中 destory()方法

##### ？？？Bean 的作用域

singleton：默认，每个容器中只有一个 bean 的实例，单例的模式由 BeanFactory 自身来维护。该对象的生命周期是与 Spring IOC 容器一致的。
prototype：为每一个 bean 请求提供一个实例。在每次注入时都会创建一个新的对象
request：bean 被定义为在每个 HTTP 请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。
session：与 request 范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。
（application：bean 被定义为在 ServletContext 的生命周期中复用一个单例对象。）
（websocket：bean 被定义为在 websocket 的生命周期中复用一个单例对象。）
global-session：全局作用域，global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。全局作用域与 Servlet 中的 session 作用域效果相同。

##### 单例 Bean 线程安全

非线程安全，框架并没有对 bean 进行多线程的封装处理。

##### ？？？Spring 设计模式

⼯⼚模式：每个 Bean 的创建通过⽅法
单例模式：默认的每个 Bean 的作⽤域都是单例
代理模式：关于 Aop 的实现通过代理模式

简单工厂：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。
Spring 中的 BeanFactory 就是简单工厂模式的体现，根据传入一个唯一的标识来获得 Bean 对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。

工厂方法：
实现了 FactoryBean 接口的 bean 是一类叫做 factory 的 bean。其特点是，spring 会在使用 getBean()调用获得该 bean 时，会自动调用该 bean 的 getObject()方法，所以返回的不是 factory 这个 bean，而是这个 bean.getOjbect()方法的返回值。

单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点
spring 对单例的实现： spring 中的单例模式完成了后半句话，即提供了全局的访问点 BeanFactory。但没有从构造器级别去控制单例，这是因为 spring 管理的是任意的 java 对象。

适配器模式：
Spring 定义了一个适配接口，使得每一种 Controller 有一种对应的适配器实现类，让适配器代替 controller 执行相应的方法。这样在扩展 Controller 时，只需要增加一个适配器类就完成了 SpringMVC 的扩展了。

装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。
Spring 中用到的包装器模式在类名上有两种表现：一种是类名中含有 Wrapper，另一种是类名中含有 Decorator。

动态代理：
切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象创建动态的创建一个代理对象。SpringAOP 就是以这种方式织入切面的。
织入：把切面应用到目标对象并创建新的代理对象的过程。

观察者模式：
spring 的事件驱动模型使用的是 观察者模式 ，Spring 中 Observer 模式常用的地方是 listener 的实现。

策略模式：
Spring 框架的资源访问 Resource 接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。

模板方法：父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。
最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好了。
refresh 方法

- **工厂设计模式** : Spring 使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
- **代理设计模式** : Spring AOP 功能的实现。
- **单例设计模式** : Spring 中的 Bean 默认都是单例的。
- **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
- **包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
- **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。
- **适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配 `Controller`。

##### Spring 事务实现方式，原理，隔离级别

有两种使用事务的方式，一种是编程式的，一种是申明式的，[@Transactional ](/Transactional ) 注解就是申明式的。 

在一个方法上加了 [@Transactional ](/Transactional ) 注解后，Spring 会基于这个类生成一个代理对象，会将这个代理对象作为 bean，当在使用这个代理对象的方法时，如果这个方法上存在 [@Transactional ](/Transactional ) 注解，那么代理逻辑会先把事务的自动提交设置为 false，然后再去执行原本的业务逻辑方法，没出异常就提交，出异常就回滚。（[@Transactional ](/Transactional ) 注解中的 rollbackFor 属性配置针对的异常，默认对 RuntimeException 和 Error 进行回滚） 

read uncommitted（读未提交）
read committed（读已提交、不可重复读）
repeatable read（可重复读）
serializable（可串行化）
四种外加一个默认，以 Spring 的隔离级别为准，如果 spring 设置的隔离级别数据库不支持，效果取决于数据库

##### Spring 事务传播机制

REQUIRED(默认的事务传播类型)：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务
SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务执行
REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起该事务。

MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。
NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则挂起当前事务
NEVER：不使用事务，如果当前事务存在，则抛出异常
NESTED：如果当前事务存在，则在嵌套事务中执行，否则开启一个事务（父子关系）

##### Spring 事务失效条件

1、发生自调用，调用者不是代理类，而是 UserService 对象本身
2、方法不是 public 的（在非 public 方法上，可以开启 AspectJ 代理模式）
3、数据库不支持事务
4、没有被 spring 管理
5、异常被吃掉，事务不会回滚(或者抛出的异常没有被定义，默认为 untime Exception)

##### Bean 自动装配

开启自动装配，只需要在 xml 配置文件中定义“autowire”属性，有五种装配的方式：
缺省：缺省情况下，自动配置是通过“ref”属性手动设定 。
byName：根据 bean 的属性名称进行自动装配。
byType：根据 bean 的类型进行自动装配。（有多个会报错）
constructor：类似 byType，不过是应用于构造器的参数。如果一个 bean 与构造器参数的类型形同，则进行自动装配，否则导致异常。
autodetect：如果有默认的构造器，则使用 constructor 方式，否则使用 byType。

@Autowired：自动装配 bean，可以在字段、setter 方法、构造函数上使用。

##### Spring Boot，Spring MVC，Spring 区别

spring 是一个 IOC 容器，用来管理 Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提供 AOP 机制。

springmvc 是 spring 对 web 框架的一个解决方案，提供了一个总的前端控制器 Servlet，用来接收请求，然后定义了一套路由策略（url 到 handle 的映射）及适配执行 handle，将 handle 结果使用视图解析技术生成视图展现给前端

springboot 是 spring 提供的一个快速开发工具包，让程序员能更方便、更快速的开发 spring+springmvc 应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter 机制）

### SpringMVC

##### SpringMVC 工作流程

1）用户发送请求至前端控制器 DispatcherServlet。
2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。
3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。
4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。
5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)
6）Controller 执行完成返回 ModelAndView。
7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。
8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。
9）ViewReslover 解析后返回具体 View。
10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。
11）DispatcherServlet 响应用户。

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038267589-c48ac59e-f535-4fc4-bf08-63b86b2935c4.png#clientId=ub01b8327-a2bc-4&from=paste&height=256&id=u764291c8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=512&originWidth=1267&originalType=binary&ratio=1&size=193850&status=done&style=none&taskId=u03b10512-ee88-4d85-bffe-4aa47fef8ce&width=633.5)

1. 客户端（浏览器）发送请求，直接请求到 `DispatcherServlet`。
2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。
3. 解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由 `HandlerAdapter` 适配器处理。
4. `HandlerAdapter` 会根据 `Handler` 来调用真正的处理器开处理请求，并处理相应的业务逻辑。
5. 处理器处理完业务后，会返回一个 `ModelAndView` 对象，`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
6. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。
7. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。
8. 把 `View` 返回给请求者（浏览器）

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038270456-d0328cc4-cc5f-419f-80e4-74b4d6fe5225.png#clientId=ub01b8327-a2bc-4&from=paste&height=288&id=u9a1308f7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=575&originWidth=856&originalType=binary&ratio=1&size=161240&status=done&style=none&taskId=u26465b3c-a3f6-44f3-a23c-95acf618696&width=428)

##### SpringMVC 主要组件（九大组件）

Handler：也就是处理器。它直接应对着 MVC 中的 C 也就是 Controller 层，它的具体表现形式有很多，可以是类，也可以是方法。在 Controller 层中 [@RequestMapping ](/RequestMapping ) 标注的所有方法都可以看成是一个 Handler，只要可以实际处理请求就可以是 Handler 
1、HandlerMapping（核心）
initHandlerMappings(context)，处理器映射器，根据用户请求的资源 uri 来查找 Handler 的。在 SpringMVC 中会有很多请求，每个请求都需要一个 Handler 处理，具体接收到一个请求之后使用哪个 Handler 进行，这就是 HandlerMapping 需要做的事。
2、HandlerAdapter（核心）
initHandlerAdapters(context)，适配器。因为 SpringMVC 中的 Handler 可以是任意的形式，只要能处理请求就 ok，但是如 Servlet 需要的处理方法的结构却是固定的，如何让固定的 Servlet 处理方法调用灵活的 Handler 来进行处理呢？这就是 HandlerAdapter 要做的事情。
Handler 是用来干活的工具；HandlerMapping 用于根据需要干的活找到相应的工具；HandlerAdapter 是使用工具干活的人。
3、HandlerExceptionResolver
initHandlerExceptionResolvers(context)， 专门处理异常，此组件的作用是根据异常设置 ModelAndView，之后再交给 render 方法进行渲染。
4、ViewResolver（核心）
initViewResolvers(context)，ViewResolver 用来将 String 类型的视图名和 Locale 解析为 View 类型的视图。View 是用来渲染页面的，也就是将程序返回的参数填入模板里，生成 html（也可能是其它类型）文件。这里就有两个关键问题：使用哪个模板？用什么技术（规则）填入参数？这其实是 ViewResolver
主要要做的工作，ViewResolver 需要找到渲染所用的模板和所用的技术（也就是视图的类型）进行渲染，具体的渲染过程则交由不同的视图自己完成。

##### 优点

1. 可以⽀持各种视图技术,⽽不仅仅局限于 JSP；
2. 与 Spring 框架集成（如 IoC 容器、AOP 等）；
3. 清晰的⻆⾊分配：前端控制器(dispat cherServlet ) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapt er), 视图解析器（ViewResolver）。
4. ⽀持各种请求资源的映射策略。

##### 重定向，转发

1. 转发：在返回值前⾯加"forward:"，譬如"forward:user.do?name=method4"
2. 重定向：在返回值前⾯加"redirect :"，譬如"redirect :[http://www.baidu.com](http://www.baidu.com)"

### SpringBoot

##### @SpringBootApplication

可以看作以下三个注解的集合。

- `@EnableAutoConfiguration`：启用 SpringBoot 的自动配置机制
- `@ComponentScan`： 扫描被 `@Component` (`@Service`,`@Controller`)注解的 bean，注解默认会扫描该类所在的包下所有的类。
- `@Configuration`：允许在上下文中注册额外的 bean 或导入其他配置类

##### ？？？48 SpringBoot 自动配置

[自动配置实现](https://xiaozhuanlan.com/topic/4923687015)；

[@Import ](/Import ) + [@Configuration ](/Configuration ) + Spring spi 
自动配置类由各个 starter 提供，使用 [@Configuration ](/Configuration ) + [@Bean ](/Bean ) 定义配置类，放到 METAINF/spring.factories 下 
使用 Spring spi 扫描 META-INF/spring.factories 下的配置类
使用 [@Import ](/Import ) 导入自动配置类 

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038281065-35a006dd-68f7-4503-beaf-899d4dd0157d.png#clientId=ub01b8327-a2bc-4&from=paste&height=299&id=u93d8f91f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=597&originWidth=1259&originalType=binary&ratio=1&size=316201&status=done&style=none&taskId=u3c1df717-75c3-4954-b213-e795d86d9ec&width=629.5)

##### ？？？SpringBoot 中的 Starter

使用 spring + springmvc 使用，如果需要引入 mybatis 等框架，需要到 xml 中定义 mybatis 需要的 bean
starter 就是定义一个 starter 的 jar 包，写一个 [@Configuration ](/Configuration ) 配置类、将这些 bean 定义在里面，然后在 starter 包的 META-INF/spring.factories 中写入该配置类，springboot 会按照约定来加载该配置类 
开发人员只需要将相应的 starter 包依赖进应用，进行相应的属性配置（使用默认配置时，不需要配置），就可以直接进行代码开发，使用对应的功能了，比如 mybatis-spring-boot--starter

##### 嵌入式服务器

节省了下载安装 tomcat，应用也不需要再打 war 包，然后放到 webapp 目录下再运行
springboot 已经内置了 tomcat.jar，运行 main 方法时会去启动 tomcat，并利用 tomcat 的 spi 机制加载
springmvc

##### ？？？拦截器，过滤器

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038284624-3ea370b2-6447-4760-b565-041dab56dd67.png#clientId=ub01b8327-a2bc-4&from=paste&height=264&id=u780afc0f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=527&originWidth=603&originalType=binary&ratio=1&size=69750&status=done&style=none&taskId=u2d4c8c33-1c8e-4c86-b785-ee14dc16d3b&width=301.5)；

拦截器：Spring 框架的，多次调用
过滤器：servlet 规范规定的，

① 拦截器是基于 java 的反射机制的，而过滤器是基于函数回调。
② 拦截器不依赖与 servlet 容器，过滤器依赖与 servlet 容器。
③ 拦截器只能对 action 请求起作用，而过滤器则可以对几乎所有的请求起作用。
④ 拦截器可以访问 action 上下文、值栈里的对象，而过滤器不能访问。
⑤ 在 action 的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。
⑥ 拦截器可以获取 IOC 容器中的各个 bean，而过滤器就不行，这点很重要，在拦截器里注入一个 service，可以调用业务逻辑。

### Mybatis

##### 优缺点

优点：
1、基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签， 支持编写动态 SQL 语句， 并可重用。
2、与 JDBC 相比，减少了 50% 以上的代码量，不需要手动开关连接；
3、与各种数据库兼容（ 因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）。
4、与 Spring 很好的集成；
5、提供映射标签， 支持对象与数据库的 ORM 字段关系映射； 提供对象关系映射标签， 支持对象关系组件维护。

缺点：
1、SQL 语句的编写工作量较大， 尤其当字段多、关联表多时， 对开发人员编写 SQL 语句的功底有一定要求。
2、SQL 语句依赖于数据库， 导致数据库移植性差， 不能随意更换数据库。

##### #{}，${}#

#{}是预编译处理、是占位符，替换为?，调用# PreparedStatement 赋值；
${}是字符串替换、是拼接符，替换为变量的值，调用 Statement 赋值；

使用#{}可以有效的防止 SQL 注入， 提高系统安全性。

##### ？？？Mybatis 的插件运行原理，如何编写

插件= 拦截器
只支持针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口

# Mysql

##### SQL 语法

[CS](https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md)；

```
select      5
  ...
from        1
  ...  
where       2
  ...  
group by    3 分组
  ...
having      4 对分组之后的数据进行再次过滤
  ...
order by    6 排序
  ...
limit       7 取部分数据
  ...;
```

```
insert into t_student (no,name) values (1,'zhangsan');
update t_student set 字段名1=值1,字段名2=值2... where 条件;
delete from t_student where 条件;
```

##### 连接查询，子查询，limit，union

内连接：两张表平等
外连接（左，右）：有主表

limit startIndex, length
startIndex 表示起始位置，从 0 开始，0 表示第一条数据。
length 表示取几个

union 可以将查询结果相加

##### 三范式

属性不能再被分割（最基本要求）
消除部分依赖（多对多：三张表，“关系”表加两个外键）（学号 学生 教师号 教师）
消除传递依赖（一对多：两张表，“多”表加外键）（学号 学生 班级号 班级）

##### 删除

drop 删表，truncate 清空数据，delete 删除数据
（DDL，DDL，DML）

##### 索引的原理，类型，优化，失效

[添加索引](https://xiaozhuanlan.com/topic/4912306758#sectionmysql-3)；

1. 把创建了索引的列的内容进行排序
2. 对排序结果生成倒排表
3. 在倒排表内容上拼上数据地址链
4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据

B+ Tree 索引

哈希索引

全文索引

空间数据索引

聚簇和非聚簇

聚簇索引：将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的
非聚簇索引：叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置再取磁盘查找数据，

优势：
1、查询通过聚簇索引可以直接获取数据，效率要高
2、聚簇索引对于范围查询的效率很高
3、聚簇索引适合用在排序的场合，非聚簇索引不适合

劣势：
1、维护索引很昂贵
2、表因为使用 UUId（随机 ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用 int 的 auto_increment 作为主键
3、如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间

InnoDB 中一定有主键，主键一定是聚簇索引，不手动设置、则会使用 unique 索引，没有 unique 索引，则会使用数据库内部的一个行的隐藏 id 来当作主键索引。
在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。

MyISM 使用的是非聚簇索引，没有聚簇索引。
如果涉及到大数据量的排序、全表扫描、count 之类的操作的话，还是 MyISAM 占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。

索引优化

- 独立的列：索引列不能是表达式的一部分，也不能是函数的参数
- 多列索引
- 索引列的顺序：选择性强的放前面
- 前缀索引：BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符
- 覆盖索引：索引包含所有需要查询的字段的值。

失效
2.复合索引未用左列字段;
3.like 以 % 开头;
7.如果 mysql 觉得全表扫描更快时（数据少）;

##### ？？？索引的数据结构，各自优劣

B+ 树：
B+ 树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过 1，而且同层级的节点间有指针相互链接。在 B+ 树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因此，B+ 树索引被广泛应用于数据库、文件系统等场景。

B+ 树索引的关键字检索效率比较平均，不像 B 树那样波动幅度大，

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038295322-f28ef203-40bb-4ae9-b091-a6204307d0a9.png#clientId=ub01b8327-a2bc-4&from=paste&height=320&id=u1bad85d7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=639&originWidth=1023&originalType=binary&ratio=1&size=234104&status=done&style=none&taskId=ud27afeba-1c2f-4723-ac99-b44b1d2bc02&width=511.5)；

哈希索引：
哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似 B+ 树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038298242-e646935e-61ee-4e7b-b431-0a6940f00e82.png#clientId=ub01b8327-a2bc-4&from=paste&height=241&id=u1bd34277&margin=%5Bobject%20Object%5D&name=image.png&originHeight=482&originWidth=1010&originalType=binary&ratio=1&size=564403&status=done&style=none&taskId=ub4d62362-ee5b-49fe-9bc3-2f16f5bf3b3&width=505)；

适合等值查询，不适合是范围查询检索
无法利用索引完成排序
无法完成以及 like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
不支持多列联合索引的最左匹配规则；
在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在哈希碰撞问题。

##### 索引设计的原则

1. 适合索引的列是出现在 where 子句中的列，或者连接子句中指定的列
2. **基数较小**的表，索引效果较差，没有必要在此列建立索引
3. 使用短索引，如果对长字符串列进行索引，应该指定一个**前缀长度**，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。
4. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
5. 定义有外键的数据列一定要建立索引。
6. **更新频繁**字段不适合创建索引
7. 若是**不能有效区分**数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
8. 尽量的扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
9. 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
10. 对于定义为 text、image 和 bit 的数据类型的列不要建立索引。

##### 最左前缀原则，最左匹配原则

多个索引，先排第一个，再排第二个

##### 锁的类型

基于锁的属性分类：共享锁、排他锁。
基于锁的粒度分类：表级锁(INNODB、MYISAM)、行级锁(INNODB)（一行或多行）、页级锁(BDB 引擎 )、记录锁（一条）、间隙锁、临键锁。
基于锁的状态分类：意向共享锁、意向排它锁。

##### ？？？mysql 执行计划

[CS Explain](https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md)；

执行计划就是 sql 的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数
EXPLAIN SELECT * from A where X=? and Y=?

1. id ：是一个有顺序的编号，是查询的顺序号，有几个 select 就显示几行。id 的顺序是按 select 出现的顺序增长的。id 列的值越大执行优先级越高越先执行，id 列的值相同则从上往下执行，id 列的值为 NULL 最后执行。
2. selectType 表示查询中每个 select 子句的类型
SIMPLE： 表示此查询不包含 UNION 查询或子查询
PRIMARY： 表示此查询是最外层的查询（包含子查询）
SUBQUERY： 子查询中的第一个 SELECT
UNION： 表示此查询是 UNION 的第二或随后的查询
DEPENDENT UNION： UNION 中的第二个或后面的查询语句, 取决于外面的查询
UNION RESULT, UNION 的结果
DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.
DERIVED：衍生，表示导出表的 SELECT（FROM 子句的子查询）
3. table：表示该语句查询的表
4. type：优化 sql 的重要字段，也是我们判断 sql 性能和优化程度重要指标。他的取值类型范围：
const：通过索引一次命中，匹配一行数据
system: 表中只有一行记录，相当于系统表；
eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配
ref: 非唯一性索引扫描,返回匹配某个值的所有
range: 只检索给定范围的行，使用一个索引来选择行，一般用于 between、<、>；
index: 只遍历索引树；
ALL: 表示全表扫描，这个类型的查询是性能最差的查询之一。 那么基本就是随着表的数量增多，执行效率越慢。
执行效率：
ALL < index < range< ref < eq_ref < const < system。最好是避免 ALL 和 index
5. possible_keys：它表示 Mysql 在执行该 sql 语句的时候，可能用到的索引信息，仅仅是可能，实际不一定会用到。
6. key：此字段是 mysql 在当前查询时所真正使用到的索引。 他是 possible_keys 的子集
7. key_len：表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，这也是我们优化 sql 时，评估索引的重要指标
8. rows：mysql 查询优化器根据统计信息，估算该 sql 返回结果集需要扫描读取的行数，这个值相关重要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大
9. filtered：返回结果的行占需要读到的行(rows 列的值)的百分比，就是百分比越高，说明需要查询到数据越准确， 百分比越小，说明查询到的数据量大，而结果集很少
10. extra
using filesort ：表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有 using filesort 都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。
using index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错。
using temporary：查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。
using where ：sql 使用了 where 过滤,效率较高。

##### 事务的基本特性和隔离级别

原子性：指的是一个事务中的操作要么全部成功，要么全部失败。
一致性：保证事务只能把数据库从一个有效（正确）的状态“转移”到另一个有效（正确）的状态。（约束条件）
隔离性：指的是一个事务的修改在最终提交前，对其他事务是不可见的。
持久性：指的是一旦事务提交，所做的修改就会永久保存到数据库中。

ACID 关系

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对系统崩溃的情况。

ACID 靠什么保证

- A 原子性由 undo log 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql
- C 一致性由其他三大特性保证、程序代码要保证业务上的一致性
- I 隔离性由 MVCC 来保证
- D 持久性由内存 +redo log 来保证，mysql 修改数据同时在内存和 redo log 记录这次操作，宕机的时候可以从 redo log 恢复，redolog 的刷盘会在系统空闲时进行

隔离级别

- read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。
- read commit 读已提交，两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已经提交的事务。
- repeatable read 可重复复读，这是 mysql 的默认级别，就是每次读取结果都一样，但是有可能产生幻读。
- serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。

存在的问题

- 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，如果由于某些原因，前一个 RollBack 了操作，则后一个事务所读取的数据就会是不正确的。
- 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
- 幻读(Phantom Read):在一个事务的两次查询中数据行数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。
- 丢失修改（修改的内容被覆盖）

##### sql 耗时，慢查询，慢查询优化

慢查询的优化首先要搞明白慢的原因是什么？是查询条件没有命中索引？是 load 了不需要的数据列？还是数据量太大？

所以优化也是针对这三个方向来的，
首先分析语句，看看是否 load 了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。
分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。
如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。

##### 大表优化

限定查询范围
读写分离（主从库）
垂直分区
水平分区

##### InnoDB 的锁的算法

##### MVCC（多版本并发控制）

[CS](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E4%BA%94%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6)；

多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，不同的事务 session 会看到自己特定版本的数据（版本链）

聚簇索引记录中有两个必要的隐藏列：
trx_id：用来存储每次对某条聚簇索引记录进行修改的时候的事务 id。
roll_pointer：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入 undo 日志中。这个 roll_pointer 就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。

开始事务时创建 readview，readView 维护当前活动的事务 id，即未提交的事务 id，排序生成一个数组访问数据，获取数据中的事务 id（获取的是事务 id 最大的记录），对比 readview：InnoDB redo log 写盘，InnoDB 事务进入 prepare 状态。
如果前面 prepare 成功，binlog 写盘，再继续将事务日志持久化到 binlog，如果持久化成功，那么 InnoDB 事务则进入 commit 状态(在 redo log 里面写一个 commit 记录)
如果在 readview 的左边（比 readview 都小），可以访问（在左边意味着该事务已经提交）
如果在 readview 的右边（比 readview 都大）或者就在 readview 中，不可以访问，获取 roll_pointer，取上一版本重新对比（在右边意味着，该事务在 readview 生成之后出现，在 readview 中意味着该事务还未提交）

已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的 ReadView
可重复读隔离级别则在第一次读的时候生成一个 ReadView，之后的读都复用之前的 ReadView

##### mysql 主从同步，读写分离

mysql 主从同步的过程：
Mysql 的主从复制中主要有三个线程： master（binlog dump thread）、slave（I/O thread 、SQLthread） ，Master 一条线程和 Slave 中的两条线程。

主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。
主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。
从节点 I/O 线程接收 binlog 内容，并将其写入到 relay log 文件中。
从节点的 SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。
注：主从节点使用 binglog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。

由于 mysql 默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。
全同步复制：主库写入 binlog 后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。
半同步复制：和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回 ACK 确认给主库，主库收到至少一个从库的确认就认为写操作完成。

读写分离能提高性能的原因在于：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

##### MyISAM 和 InnoDB

MyISAM：
不支持事务，但是每次查询都是原子的；
支持表级锁，即每次操作是对整个表加锁；
存储表的总行数；
一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件；
采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引
不用保证唯一性。
提供了大量的特性，包括压缩表、空间数据索引等。

InnoDb：
支持 ACID 的**事务**，支持事务的四种隔离级别；
支持**行级锁**及**外键**约束：因此可以支持写并发；
不存储总行数；
主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持 B+ 树结构，文件的大调整。
支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。
崩溃后的安全恢复
MVCC

##### 乐观锁，悲观锁

悲观锁：版本号机制，CAS 算法

##### mysql 中索引类型及对数据库的性能的影响

普通索引：允许被索引的数据列包含重复的值。
唯一索引：可以保证数据记录的唯一性。
主键索引：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。
联合索引：索引可以覆盖多个数据列，如像 INDEX(columnA, columnB)索引。
全文索引：通过建立倒排索引,可以极大的提升检索效率,解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。

通提高查询性能，降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件
索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都会跟着变。

##### SQL 语法

[CS](https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md)；

##### ？？？CallableStatement

CallableStatement 用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个 CallableStatement 的方法是：
CallableStatement Connection.prepareCall();

# Redis

##### 持久化（RDB，AOF）

**RDB：Redis DataBase**

在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。

优点：
1、整个 Redis 数据库将只包含一个文件 dump.rdb，方便持久化。
2、容灾性好，方便备份。
3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能
4、相对于数据集大时，比 AOF 的启动效率更高。

缺点：
1、数据安全性低。间隔长会发生数据丢失。
2、由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟。

**AOF：Append Only File**

以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录

优点：
1、数据安全，Redis 中提供了 3 中同步策略，即每秒同步、每修改同步和不同步。
2、通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redischeck-aof 工具解决数据一致性问题。
3、AOF 机制的 rewrite 模式。定期对 AOF 文件进行重写，以达到压缩的目的。

缺点：
1、AOF 文件比 RDB 文件大，且恢复速度慢。
2、数据集大的时候，比 rdb 启动效率低。
3、运行效率没有 RDB 高

AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。
AOF 比 RDB 更安全也更大
RDB 性能比 AOF 好
如果两个都配了优先加载 AOF

##### 过期键删除

Redis 是 key-value 数据库，我们可以设置 Redis 中缓存的 key 的过期时间。Redis 的过期策略就是指当 Redis 中缓存的 key 过期了。

- 惰性过期：只有当访问一个 key 时，才会判断该 key 是否已过期，过期则清除。
该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。
- 定期过期：每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。
该策略是一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。
- 内存淘汰机制（6 种）

##### 线程模型，单线程快的原因

Redis 基于 Reactor 模式开发了网络事件处理器，这个处理器叫做文件事件处理器 file event handler。
这个文件事件处理器，它是单线程的，所以 Redis 才叫做单线程的模型，它采用 IO 多路复用机制来同时监听多个 Socket，根据 Socket 上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能
的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了 Redis 内部的线程模型的简单性。
文件事件处理器的结构包含 4 个部分：多个 Socket、IO 多路复用程序、文件事件分派器以及事件处理器
（命令请求处理器、命令回复处理器、连接应答处理器等）。
多个 Socket 可能并发的产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 Socket，会将 Socket 放入一个队列中排队，每次从队列中取出一个 Socket 给事件分派器，事件分派器把 Socket 给对应的事件处理器。
然后一个 Socket 的事件处理完之后，IO 多路复用程序才会将队列中的下一个 Socket 给事件分派器。文件事件分派器会根据每个 Socket 当前产生的事件，来选择对应的事件处理器来处理。
单线程快的原因：
1）纯内存操作
2）核心是基于非阻塞的 IO 多路复用机制
3）单线程反而避免了多线程的频繁上下文切换带来的性能问题

##### 事务

MULTI、EXEC、DISCARD、WATCH、UNWATCH

详细描述

```
1、事务开始
MULTI 命令的执行，标识着一个事务的开始。MULTI命令会将客户端状态的flags 属性中打开REDIS_MULTI 标识来完成的。
2、命令入队
当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的一个，立即执行这个命令，否则将命令放入一个事务队列里面，然后向客户端返回QUEUED 回复
如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器立即执行这个命令。
如果客户端发送的是四个命令以外的其他命令，那么服务器并不立即执行这个命令。
首先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭 REDIS_MULTI 标识，并且返回错误信息给客户端。
如果正确，将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复事务队列是按照FIFO的方式保存入队的命令
3、事务执行
客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑。
如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者 REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行。
否则客户端处于事务状态（flags 有 REDIS_MULTI 标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端；
redis 不支持事务回滚机制，但是它会检查每一个事务中的命令是否错误。
Redis 事务不支持检查那些程序员自己逻辑错误。例如对 String 类型的数据库键执行对 HashMap 类型的操作！
WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。
MULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。
EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。
通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
UNWATCH命令可以取消watch对所有key的监控。
```

##### 集群

主从
哨兵模式：
sentinel，哨兵是 redis 集群中非常重要的一个组件，主要有以下功能：

- 集群监控：负责监控 redis master 和 slave 进程是否正常工作。
消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。
配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。

哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。

- 故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举
即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的
哨兵通常需要 3 个实例，来保证自己的健壮性。
哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。
对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。

**Redis Cluster**

是一种服务端 Sharding 技术，3.0 版本开始正式提供。采用 slot(槽)的概念，一共分成 16384 个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行
方案说明

- 通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了 16384 个槽位
每份数据分片会存储在多个互为主从的多节点上
数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)
同一分片多个节点间的数据不保持强一致性
读取数据时，当客户端操作的 key 没有分配在该节点上时，redis 会返回转向指令，指向正确的节点
扩容时需要需要把旧节点的数据迁移一部分到新节点

在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。
16379 端口号是用来进行节点间通信的，也就是 cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。
优点

- 无中心架构，支持动态扩容，对业务透明
具备 Sentinel 的监控和自动 Failover(故障转移)能力
客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可
高性能，客户端直连 redis 服务，免去了 proxy 代理的损耗

缺点

- 运维也很复杂，数据迁移需要人工干预
只能使用 0 号数据库
不支持批量操作(pipeline 管道操作)
分布式逻辑和存储模块耦合等

Redis Sharding 是 Redis Cluster 出来之前，业界普遍使用的多 Redis 实例集群方法。其主要思想是采用哈希算法将 Redis 数据的 key 进行散列，通过 hash 函数，特定的 key 会映射到特定的 Redis 节点上。Java redis 客户端驱动 jedis，支持 Redis Sharding 功能，即 ShardedJedis 以及结合缓存池的 ShardedJedisPool
优点
优势在于非常简单，服务端的 Redis 实例彼此独立，相互无关联，每个 Redis 实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强
缺点
由于 sharding 处理放到客户端，规模进一步扩大时给运维带来挑战。
客户端 sharding 不支持动态增删节点。服务端 Redis 实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化

##### 主从复制原理

通过执行 slaveof 命令或设置 slaveof 选项，让一个服务器去复制另一个服务器的数据。
主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。
一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。

全量复制：
1）主节点通过 bgsave 命令 fork 子进程进行 RDB 持久化，该过程是非常消耗 CPU、内存(页表复制)、硬盘 IO 的
2）主节点通过网络将 RDB 文件发送给从节点，对主从节点的带宽都会带来很大的消耗
3）从节点清空老数据、载入新 RDB 文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行 bgrewriteaof，也会带来额外的消耗

部分复制：
1）复制偏移量：执行复制的双方，主从节点，分别会维护一个复制偏移量 offset
2）复制积压缓冲区：主节点内部维护了一个固定长度的、先进先出(FIFO)队列 作为复制积压缓冲区，当主从节点 offset 的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。
3）服务器运行 ID(runid)：每个 Redis 节点，都有其运行 ID，运行 ID 由节点在启动时自动生成，主节点会将自己的运行 ID 发送给从节点，从节点会将主节点的运行 ID 存起来。 从节点 Redis 断开重连的时候，就是根据运行 ID 来判断同步的进度：
如果从节点保存的 runid 与主节点现在的 runid 相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看 offset 和复制积压缓冲区的情况)；
如果从节点保存的 runid 与主节点现在的 runid 不同，说明从节点在断线前同步的 Redis 节点并不是当前的主节点，只能进行全量复制。

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038316288-3ce952c8-04ed-48f7-8b1b-c2ac16a3f4c8.png#clientId=ub01b8327-a2bc-4&from=paste&height=363&id=ua0b59fae&margin=%5Bobject%20Object%5D&name=image.png&originHeight=725&originWidth=992&originalType=binary&ratio=1&size=106594&status=done&style=none&taskId=u3d397b76-219b-4fa7-9469-555ad934341&width=496)；

##### 缓存击穿，缓存雪崩，缓存穿透

缓存击穿：缓存中某个数据失效，所以后面的请求都会落到数据库上，造成数据库压力瞬间增大。

- 不设置过期时间，在属性中设置过期时间，获取数据时检查，快过期就更新（可能会拿到过期的值）
- 设置热点数据永远不过期，并加互斥锁保证单线程写。

缓存雪崩：缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
- 双缓存 + 缓存预热
- 互斥锁

缓存穿透：缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。

- 接口层增加校验，如用户鉴权校验，id 做基础校验，id<=0 的直接拦截；
- 从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个 id 暴力攻击
- 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力

# 分布式/微服务

##### CAP，BASE

**CAP**

Consistency (一致性)：
即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致。
客户端：并发访问时更新过的数据如何获取的问题。
服务端：更新如何复制分布到整个系统，以保证数据最终一致。

Availability (可用性):
即服务一直可用，而且是正常响应时间。系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。

Partition Tolerance (分区容错性):
即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

**BASE**

Basically Available（基本可用）
响应时间上：处理请求的时间变长
系统功能上：系统的部分功能无法使用。

Soft state（软状态）
数据同步允许一定的延迟

Eventually consistent（最终一致性）
系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，不要求实时。

BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的。

##### 负载均衡

算法

1、轮询法、加权轮询法
2、随机法、加权随机法
3、最小连接数法
4、源地址哈希法

类型

DNS 方式实现负载均衡
硬件负载均衡：F5 和 A10
软件负载均衡：Nginx 、HAproxy 、LVS 。其中的区别：
Nginx ：七层负载均衡，支持 HTTP、E-mail 协议，同时也支持 4 层负载均衡；
HAproxy ：支持七层规则的，性能也很不错。OpenStack 默认使用的负载均衡软件就是 HAproxy；
LVS ：运行在内核态，性能是软件负载均衡中最高的，严格来说工作在三层，所以更通用一些，适用各种应用服务。

##### 分布式 Session 共享方案

1、采用无状态服务，抛弃 session
2、存入 cookie（有安全风险）
3、服务器之间进行 Session 同步
4、 IP 绑定策略
5、使用 Redis 存储（水平扩展，重启不丢失）

##### 分布式 id 生成方案

uuid

```
1，当前日期和时间 时间戳
2，时钟序列。 计数器
3，全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。
优点：代码简单，性能好（本地生成，没有网络消耗），保证唯一（相对而言，重复概率极低可以忽
略）
缺点：
每次生成的ID都是无序的，而且不是全数字，且无法保证趋势递增。
UUID生成的是字符串，字符串存储性能差，查询效率慢，写的时候由于不能产生顺序的append操作，需要进 行insert操作，导致频繁的页分裂，这种操作在记录占用空间比较大的情况下，性
能下降比较大，还会增加读 取磁盘次数
UUID长度过长，不适用于存储，耗费数据库性能。
ID无一定业务含义，可读性差。
有信息安全问题，有可能泄露mac地址
```

数据库自增序列

```
单机模式：
优点：
实现简单，依靠数据库即可，成本小。
ID数字化，单调自增，满足数据库存储和查询性能。
具有一定的业务可读性。（结合业务code）
缺点：
强依赖DB，存在单点问题，如果数据库宕机，则业务不可用。
DB生成ID性能有限，单点数据库压力大，无法扛高并发场景。
信息安全问题，比如暴露订单量，url查询改一下id查到别人的订单
数据库高可用：多主模式做负载，基于序列的起始值和步长设置，不同的初始值，相同的步长，步长大于节点数
优点：
解决了ID生成的单点问题，同时平衡了负载。
缺点：
系统扩容困难：系统定义好步长之后，增加机器之后调整步长困难。
数据库压力大：每次获取一个ID都必须读写一次数据库。
主从同步的时候：电商下单->支付insert master db select数据 ，因为数据同步延迟导致
查不到这个数 据。加cache(不是最好的解决方式)数据要求比较严谨的话查master主库。
```

雪花算法

```
生成一个64bit的整性数字
第一位符号位固定为0，41位时间戳，10位workId，12位序列号
位数可以有不同实现
优点：
每个毫秒值包含的ID值很多，不够可以变动位数来增加，性能佳（依赖workId的实现）。
时间戳值在高位，中间是固定的机器码，自增的序列在低位，整个ID是趋势递增的。
能够根据业务场景数据库节点布置灵活挑战bit位划分，灵活度高。
缺点：
强依赖于机器时钟，如果时钟回拨，会导致重复的ID生成，所以一般基于此的算法发现时钟回拨，都会抛异常处 理，阻止ID生成，这可能导致服务不可用。
```

##### 分布式锁

需要这个锁独立于每一个服务之外，而不是在服务里面。

**数据库锁**

利用主键冲突控制一次只有一个线程能获取锁，非阻塞、不可重入、单点、失效时间

**Zookeeper 分布式锁**

zk 通过临时节点，解决了死锁的问题，一旦客户端获取到锁之后突然挂掉（Session 连接断开），那么这个临节点就会自动删除掉，其他客户端自动获取锁。临时顺序节点解决惊群效应

**Redis 分布式锁**

setNX，单线程处理网络请求，不需要考虑并发安全性
所有服务节点设置相同的 key，返回为 0、则锁获取失败

问题：
1、早期版本没有超时参数，需要单独设置，存在死锁问题（中途宕机）
2、后期版本提供加锁与设置时间原子操作，但是存在任务超时，锁自动释放，导致并发问题，加锁与释放锁不是同一线程问题

删除锁：判断线程唯一标志，再删除
可重入性及锁续期没有实现，通过 redisson 解决（类似 AQS 的实现，看门狗监听机制）
redlock：意思的机制都只操作单节点、即使 Redis 通过 sentinel 保证高可用，如果这个 master 节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况（redis 同步设置可能数据丢失）。redlock 从多个节点申请锁，当一半以上节点获取成功、锁才算获取成功，redission 有相应的实现

##### 分布式事务

**XA 规范**

分布式事务规范，定义了分布式事务模型
四个角色：事务管理器(协调者 TM)、资源管理器(参与者 RM)，应用程序 AP，通信资源管理器 CRM
全局事务：一个横跨多个数据库的事务，要么全部提交、要么全部回滚

两阶段协议：

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038326667-b40bac9b-a87c-4c07-83dc-7967a4facc78.png#clientId=ub01b8327-a2bc-4&from=paste&height=282&id=u60a9fae6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=564&originWidth=1185&originalType=binary&ratio=1&size=115296&status=done&style=none&taskId=ue4fe0e77-1320-4442-aa25-e7a08dd6216&width=592.5)；

第一阶段（ prepare ） ：每个参与者执行本地事务但不提交，进入 ready 状态，并通知协调者已经准备就绪。
第二阶段（ commit ） 当协调者确认每个参与者都 ready 后，通知参与者进行 commit 操作；如果有参与者 fail ，则发送 rollback 命令，各参与者做回滚。

问题：
单点故障：一旦事务管理器出现故障，整个系统不可用（参与者都会阻塞住）
数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
响应时间较长：参与者和协调者资源都被锁住，提交或者回滚之后才能释放
不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。

三阶段协议：

主要是针对两阶段的优化，解决了 2PC 单点故障的问题，但是性能问题和不一致问题仍然没有根本解决

引入了超时机制解决参与者阻塞的问题，超时后本地提交，2pc 只有协调者有超时机制

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038330736-9038ef89-a555-4633-9013-027cde59f166.png#clientId=ub01b8327-a2bc-4&from=paste&height=337&id=uce99732a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=674&originWidth=1158&originalType=binary&ratio=1&size=161736&status=done&style=none&taskId=u6ff4e6a5-2a0c-450f-93e2-03e6ed730d4&width=579)；
第一阶段：CanCommit 阶段，协调者询问事务参与者，是否有能力完成此次事务。
第二阶段：PreCommit 阶段，此时协调者会向所有的参与者发送 PreCommit 请求，参与者收到后开始执行事务操作。参与者执行完事务操作后，就会向协调者反馈。
第三阶段：DoCommit 阶段， 向所有的参与者节点发送"doCommit"请求，参与者节点在收到提交请求后提交事务，并向协调者节点反馈消息，协调者收到所有参与者的 Ack 消息后完成事务。

**TCC（补偿事务）**

Try、Confirm、Cancel
针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作
Try 操作做业务检查及资源预留，Confirm 做业务确认操作，Cancel 实现一个与 Try 相反的操作既回滚操作。TM 首先发起所有的分支事务的 try 操作，任何一个分支事务的 try 操作执行失败，TM 将会发起所有分支事务的 Cancel 操作，若 try 操作全部成功，TM 将会发起所有分支事务的 Confirm 操作，其中 Confirm/Cancel 操作若执行失败，TM 会进行重试。
TCC 模型对业务的侵入性较强，改造的难度较大，每个操作都需要有 try 、confirm 、cancel 三个接口实现
confirm 和 cancel 接口还必须实现幂等性。

**消息队列的事务消息**

发送 prepare 消息到消息中间件，发送成功后，执行本地事务
如果事务执行成功，则 commit，消息中间件将消息下发至消费端（commit 前，消息不会被消费）
如果事务执行失败，则回滚，消息中间件将这条 prepare 消息删除
消费端接收到消息进行消费，如果消费失败，则不断重试

##### 接口幂等性

唯一 id。每次操作，都根据操作和内容生成唯一的 id，在执行之前先判断 id 是否存在，如果不存在则执行后续操作，并且保存到数据库或者 redis 等。
服务端提供发送 token 的接口，业务调用接口前先获取 token,然后调用业务接口请求时，把 token 携带过去,务器判断 token 是否存在 redis 中，存在表示第一次请求，可以继续执行业务，执行业务完成后，最后需要把 redis 中的 token 删除
建去重表。将业务中有唯一标识的字段保存到去重表，如果表中存在，则表示已经处理过了
版本控制。增加版本号，当版本号符合时，才能更新数据
状态控制。例如订单有状态已支付 未支付 支付中 支付失败，当处于未支付的时候才允许修改为支付中等

##### Spring Cloud 和 Dubbo 的区别

底层协议：springcloud 基于 http 协议，dubbo 基于 Tcp 协议（性能更好）
注册中心：Spring Cloud 使用的 eureka ，dubbo 推荐使用 zookeeper
模型定义：dubbo 将一个接口定义为一个服务，SpringCloud 则是将一个应用定义为一个服务
SpringCloud 是一个生态，而 Dubbo 是 SpringCloud 生态中关于服务调用一种解决方案（服务治理）

### SpringCloud

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038336835-6542ba0d-d7ce-4f53-ad6d-80b797ec59e8.png#clientId=ub01b8327-a2bc-4&from=paste&height=275&id=ufc27df4e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=550&originWidth=1006&originalType=binary&ratio=1&size=144347&status=done&style=none&taskId=u0ef8c715-124e-4a3c-a3bf-68bc5829a6b&width=503)；

###### Eureka：服务注册与发现

注册：每个服务都向 Eureka 登记自己提供服务的元数据，包括服务的 ip 地址、端口号、版本号、通信协议等。eureka 将各个服务维护在了一个服务清单中。同时对服务维持心跳，剔除不可用的服务，eureka 集群各节点相互注册每个实例中都有一样的服务清单。

发现：eureka 注册的服务之间调用不需要指定服务地址，而是通过服务名向注册中心咨询，并获取所有服务实例清单(缓存到本地)，然后实现服务的请求访问。

###### Ribbon

服务间发起请求的时候，基于 Ribbon 做负载均衡，从⼀个服务的多台机器中选择⼀台 （被调用方的服务地址有多个），Ribbon 也是通过发起 http 请求，来进行的调用，只不过是通过调用服务名的地址来实现的。

###### Feign

基于 Feign 的动态代理机制，根据注解和选择的机器，拼接请求 URL 地址，发起请求 ，简化服务间的调用，在 Ribbon 的基础上进行了进一步的封装。单独抽出了一个组件，就是 Spring Cloud Feign。在引入 Spring Cloud Feign 后，我们只需要创建一个接口并用注解的方式来配置它，即可完成对服务提供方的接口绑定。

```
@RestController
public class UserController {
    @GetMapping("/getUser")
    public String getUser(){
        List<String> list = new ArrayList<>();
        list.add("张三");
        String json = JSON.toJSONString(list);
        return json;
    }
}
@FeignClient(name = "user")
public interface UserClient {
    @GetMapping("/getUser")
    String getUser();
}
@RestController
public class TestController {
    @Resource
    UserClient userClient;
    @RequestMapping("/test")
    public String test(){
        String user = userClient.getUser();
        return user;
    }
}
```

###### Hystrix

发起请求是通过 Hystrix 的线程池来⾛的，不同的服务⾛不同的线程池，实现了不同服务调⽤的隔离，通过统计接口超时次数返回默认值，实现服务熔断和降级

分布式容错框架

- 阻止故障的连锁反应，实现熔断
- 快速失败，实现优雅降级
- 提供实时的监控和告警

资源隔离：线程隔离，信号量隔离

- 线程隔离：Hystrix 会给每一个 Command 分配一个单独的线程池，这样在进行单个服务调用的时候，就可以在独立的线程池里面进行，而不会对其他线程池造成影响
- 信号量隔离：客户端需向依赖服务发起请求时，首先要获取一个信号量才能真正发起调用，由于信号量的数量有限，当并发请求量超过信号量个数时，后续的请求都会直接拒绝，进入 fallback 流程。信号量隔离主要是通过控制并发请求量，防止请求线程大面积阻塞，从而达到限流和防止雪崩的目的。

熔断：为了防止异常不扩散，保证系统的稳定性
降级：编写好调用失败的补救逻辑，然后对服务直接停止运行，这样这些接口就无法正常调用，但又不至于直接报错，只是服务水平下降

###### Zuul

如果前端、移动端要调⽤后端系统，统⼀从 Zuul ⽹关进⼊，由 Zuul ⽹关转发请求给对应的服务，通过与 Eureka 进行整合，将自身注册为 Eureka 下的应用，从 Eureka 下获取所有服务的实例，来进行服务的路由。Zuul 还提供了一套过滤器机制，开发者可以自己指定哪些规则的请求需要执行校验逻辑，只有通过校验逻辑的请求才会被路由到具体服务实例上，否则返回错误提示。

### Dubbo

五个角色：
注册中心 registry：服务注册与发现
服务提供者 provider：暴露服务
服务消费者 consumer：调用远程服务
监控中心 monitor：统计服务的调用次数和调用时间
容器 container：服务允许容器

调用流程：
1：container 容器负责启动、加载、运行 provider
2：provider 在启动时，向 regisitry 中心注册自己提供的服务
3：consumer 在启动时，向 regisitry 中心订阅自己所需的服务
4：regisitry 返回服务提供者列表给 consumer，如果有变更，registry 将基于长连接推送变更数据给 consumer
5：consumer 调用 provider 服务，基于负载均衡算法进行调用
6：consumer 调用 provider 的统计，基于短链接定时每分钟一次统计到 monitor

### ZooKeeper

##### ZAB 协议

ZAB 协议包括两种基本的模式：崩溃恢复和消息广播。整个 ZooKeeper 集群的一致性保证就是这两个状态之间切换。

消息广播：
集群中所有的事务请求都由 Leader 节点来处理，其他服务器为 Follower，Leader 将客户端的事务请求转换为事务 Proposal，并且将 Proposal 分发给集群中其他所有的 Follower。
完成广播之后，Leader 等待 Follwer 反馈，当有过半数的 Follower 反馈信息后，Leader 将再次向集群内 Follower 广播 Commit 信息，Commit 信息就是确认将之前的 Proposal 提交。
Leader 节点的写入是一个两步操作，第一步是广播事务操作，第二步是广播提交操作，其中过半数指的是反馈的节点数 >=N/2+1，N 是全部的 Follower 节点数量。

崩溃恢复：
初始化集群，刚刚启动的时候
Leader 崩溃，因为故障宕机
Leader 失去了半数的机器支持，与集群中超过一半的节点断连
此时开启新一轮 Leader 选举，选举产生的 Leader 会与过半的 Follower 进行同步，使数据一致，当与过半的机器同步完成后，就退出恢复模式， 然后进入消息广播模式

Zxid

Zab 协议的事务编号，64 位的数字，低 32 位是一个简单的单调递增计数器，针对客户端每一个事务请求，计数器加 1；而高 32 位则代表 Leader 周期年代的编号。
Leader 周期（ epoch），可以理解为当前集群所处的年代或者周期，每当有一个新的 Leader 选举出现时，就会从这个 Leader 服务器上取出其本地日志中最大事务的 Zxid，并从中读取 epoch 值，然后加 1，以此作为新的周期 ID。高 32 位代表了每代 Leader 的唯一性，低 32 位则代表了每代 Leader 中事务的唯一性。

zab 节点的三种状态：
following：服从 leader 的命令
leading：负责协调事务
election/looking：选举状态

##### ？？？zk 的数据模型和节点类型

数据模型：树形结构
zk 维护的数据主要有：客户端的会话（session）状态及数据节点（dataNode）信息。
zk 在内存中构造了个 DataTree 的数据结构，维护着 path 到 dataNode 的映射以及 dataNode 间的树状层级关系。为了提高读取性能，集群中每个服务节点都是将数据全量存储在内存中。所以，zk 最适于读多写少且轻量级数据的应用场景。
数据仅存储在内存是很不安全的，zk 采用事务日志文件及快照文件的方案来落盘数据，保障数据在不丢失的情况下能快速恢复。

树中的每个节点被称为— Znode
Znode 兼具文件和目录两种特点。可以做路径标识，也可以存储数据，并可以具有子 Znode。具有增、删、改、查等操作。
Znode 具有原子性操作，读操作将获取与节点相关的所有数据，写操作也将 替换掉节点的所有数据。
另外，每一个节点都拥有自己的 ACL(访问控制列 表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作
Znode 存储数据大小有限制。每个 Znode 的数据大小至多 1M，常规使用中应该远小于此值。
Znode 通过路径引用，如同 Unix 中的文件路径。路径必须是绝对的，因此他们必须由斜杠字符来开头。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在 ZooKeeper 中，路径由 Unicode 字符串组成，并且有一些限制。字符串"/zookeeper"用以保存管理信息，比如关键配额信息。

持久节点：一旦创建、该数据节点会一直存储在 zk 服务器上、即使创建该节点的客户端与服务端的会话关闭了、该节点也不会被删除
临时节点：当创建该节点的客户端会话因超时或发生异常而关闭时、该节点也相应的在 zk 上被删除 。
有序节点：不是一种单独种类的节点、而是在持久节点和临时节点的基础上、增加了一个节点有序的性质 。

##### zk 的命名服务、配置管理、集群管理

命名服务：通过指定的名字来获取资源或者服务地址
配置管理：统一管理多节点（服务）的配置
集群管理：集群管理包括集群监控和集群控制

##### zk 的 watch 机制

客户端，可以通过在 znode 上设置 watch，实现实时监听 znode 的变化
Watch 事件是一个一次性的触发器，当被设置了 Watch 的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端
父节点的创建，修改，删除都会触发 Watcher 事件。
子节点的创建，删除会触发 Watcher 事件。
一次性：一旦被触发就会移除，再次使用需要重新注册，因为每次变动都需要通知所有客户端，一次性可以减轻压力，3.6.0 默认持久递归，可以触发多次
轻量：只通知发生了事件，不会告知事件内容，减轻服务器和带宽压力
Watcher 机制包括三个角色：客户端线程、客户端的 WatchManager 以及 ZooKeeper 服务器

1. 客户端向 ZooKeeper 服务器注册一个 Watcher 监听，
2. 把这个监听信息存储到客户端的 WatchManager 中
3. 当 ZooKeeper 中的节点发生变化时，会通知客户端，客户端会调用相应 Watcher 对象中的回调方法。watch 回调是串行同步的

##### zk 和 eureka 的区别

zk：CP 设计(强一致性)，目标是一个分布式的协调系统，用于进行资源的统一管理。当节点 crash 后，需要进行 leader 的选举，在这个期间内，zk 服务是不可用的。
eureka：AP 设计（高可用），目标是一个服务注册发现系统，专门用于微服务的服务发现注册。
Eureka 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而 Eureka 的客户端在向某个 Eureka 注册时如果发现连接失败，会自动切换至其他节点，只要有一台 Eureka 还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证强一致性）
同时当 eureka 的服务端发现 85% 以上的服务都没有心跳的话，它就会认为自己的网络出了问题，就不会从服务列表中删除这些失去心跳的服务，同时 eureka 的客户端也会缓存服务信息。

# MQ

##### RabbitMQ 架构设计

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038350792-a7526ab0-092d-441d-bf23-6d69d8653b32.png#clientId=ub01b8327-a2bc-4&from=paste&height=270&id=uf5d0d05f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=540&originWidth=944&originalType=binary&ratio=1&size=344676&status=done&style=none&taskId=u38c12694-5c9d-4f8d-9d24-e895d3ab594&width=472)；

Broker
RabbitMQ 的服务节点

Queue
RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊(轮询)给多个消费者进行消费，而不是每个消费者都收到所有的消息进行消费。

Exchange
生产者将消息发送到 Exchange，由交换器将消息路由到一个或多个队列中。

RoutingKey
生产者将消息发送给交换器的时候，一般会指定一个 RoutingKey，用来指定这个消息的路由规则。这个路由 Key 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时通过指定 RoutingKey 来决定消息流向哪里。

BindingKey
通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键。
交换器和队列实际上是多对多关系。就像关系数据库中的两张表。在投递消息时，通过 Exchange 和 RoutingKey(对应 BindingKey)就可以找到相对应的队列。

信道
信道是建立在 Connection 之上的虚拟连接。当应用程序与 Rabbit Broker 建立 TCP 连接的时候，客户端紧接着可以创建一个 AMQP 信道(Channel) ，每个信道都会被指派一个唯一的 D。RabbitMQ 处理的每条 AMQP 指令都是通过信道完成的。信道就像电缆里的光纤束。一条电缆内含有许多光纤束，允许所有的连接通过多条光线束进行传输和接收。

##### ？？？RabbitMQ 如何确保消息发送与接收

发送方

```
信道需要设置为 confirm 模式，则所有在信道上发布的消息都会分配一个唯一ID。
一旦消息被投递到queue（可持久化的消息需要写入磁盘），信道会发送一个确认给生产者（包含消息唯一ID）。
如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（未确认）消息给生产者。
所有被发送的消息都将被 confirm（即 ack） 或者被nack一次。但是没有对消息被 confirm 的快慢做任何保证，并且同一条消息不会既被 confirm又被nack
发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者，生产者的回调方法会被触发。
ConfirmCallback接口：只确认是否正确到达 Exchange 中，成功到达则回调ReturnCallback接口：消息失败返回时回调
```

接收方

```
消费者在声明队列时，可以指定noAck参数，当noAck=false时，RabbitMQ会等待消费者显式发回ack信号后才从内存(或者磁盘，持久化消息)中移去消息。否则，消息被消费后会被立即删除。
消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。
RabbitMQ不会为未ack的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开。这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很长。保证数据的最终一致性；
如果消费者返回ack之前断开了链接，RabbitMQ 会重新分发给下一个订阅的消费者。（可能存在消息重复消费的患，需要去重）
```

##### ？？？RabbitMQ 事务消息

通过对信道的设置实现

1. channel.txSelect()；通知服务器开启事务模式；服务端会返回 Tx.Select-Ok
2. channel.basicPublish；发送消息，可以是多条，可以是消费消息提交 ack
3. channel.txCommit()提交事务；
4. channel.txRollback()回滚事务；

消费者使用事务：

autoAck=false，手动提交 ack，以事务提交或回滚为准；autoAck=true，不支持事务的，也就是说你即使在收到消息之后在回滚事务也是于事无补的，队列已经把消息移除了

如果其中任意一个环节出现问题，就会抛出 IoException 异常，用户可以拦截异常进行事务回滚，或决定要不要重复消息。

事务消息会降低 rabbitmq 的性能

##### RabbitMQ 死信队列、延时队列

1. 消息被消费方否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时 requeue 属性被设置为 false 。
2. 消息在队列的存活时间超过设置的 TTL 时间。
3. 消息队列的消息数量已经超过最大队列长度。

那么该消息将成为“死信”。“死信”消息会被 RabbitMQ 进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃
为每个需要使用死信的业务队列配置一个死信交换机，这里同一个项目的死信交换机可以共用一个，然后为每个业务队列分配一个单独的路由 key，死信队列只不过是绑定在死信交换机上的队列，死信交换机也不是什么特殊的交换机，只不过是用来接受死信的交换机，所以可以为任何类型【Direct、Fanout、Topic】

TTL：一条消息或者该队列中的所有消息的最大存活时间
如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为“死信”。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用。
只需要消费者一直消费死信队列里的消息

# Linux

# 计算机网络

##### 分层

应用层：通过应用进程间的交互来完成特定网络应用
（报文）（域名系统 DNS，HTTP 协议）

运输层：负责向两台主机进程之间的通信提供通用的数据传输服务
（报文段）（TCP，UDP）

网络层：选择合适的网间路由和交换结点， 确保数据及时传送
（分组/数据报）（IP 协议）

数据链路层：两台主机之间的数据传输，是在一段一段的链路上传送的
（帧）

物理层：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异
（比特）

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038359631-22201a9b-470d-46fc-86af-8b5d8c7e3e65.png#clientId=ub01b8327-a2bc-4&from=paste&height=794&id=u2ed59f90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1587&originWidth=1120&originalType=binary&ratio=1&size=376035&status=done&style=none&taskId=u35c809f1-225b-45ca-867a-0c4ffc148a3&width=560)

##### TCP 三次握手和四次挥手

三次握手

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038364160-a8d4725c-2ceb-49a1-ab65-b11f082afd8f.png#clientId=ub01b8327-a2bc-4&from=paste&height=269&id=uee0909c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=537&originWidth=593&originalType=binary&ratio=1&size=152576&status=done&style=none&taskId=u0679c929-09c8-4115-a7cb-cc8c7edb276&width=296.5);

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

SYN 作用：告诉发送端，我接收到的信息确实就是你所发送的信号
ACK 作用：接收方到发送方的通道还需要 ACK 信号来进行验证

为什么 TCP 客户端最后还要发送一次确认：防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

四次挥手

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038368361-278d8391-660c-4a0a-8afc-78ec65e63c69.png#clientId=ub01b8327-a2bc-4&from=paste&height=212&id=u857abc17&margin=%5Bobject%20Object%5D&name=image.png&originHeight=423&originWidth=634&originalType=binary&ratio=1&size=115743&status=done&style=none&taskId=ua1ed94c4-7bed-4683-9b15-53a9888f8c4&width=317)；

客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号
服务器-关闭与客户端的连接，发送一个 FIN 给客户端
客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

##### TCP，UDP

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038374937-9a1bf30f-cce7-46a3-9d34-42c5dd5bb01a.png#clientId=ub01b8327-a2bc-4&from=paste&height=111&id=u87c81b67&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=862&originalType=binary&ratio=1&size=51220&status=done&style=none&taskId=u3875d4e7-dbc5-4b5d-a280-6d265505a3e&width=431)

##### ？？？TCP 如何保证可靠传输

##### 浏览器中输入 url 地址 ->> 显示主页的过程(面试常客)

1. DNS 解析
2. TCP 连接
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 连接结束

##### URI = URL + URN

![image.png](https://cdn.nlark.com/yuque/0/2021/png/12407496/1636038377935-42500e85-c2be-43ff-bfb3-aa3c8b283c2f.png#clientId=ub01b8327-a2bc-4&from=paste&height=137&id=ueaea5afe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=274&originWidth=590&originalType=binary&ratio=1&size=44563&status=done&style=none&taskId=udb870069-a6cf-4f53-acab-3e1fdc202b8&width=295)

##### 请求和响应报文

请求
请求行：第一行是包含了请求方法、URL、协议版本；
请求头：（get 方式的参数）接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
空白行：一个空行用来分隔首部和内容主体 Body
请求体：（post 方式的参数）最后是请求的内容主体

响应
状态行：第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
响应头：（content-type 指定浏览器使用对应编译器，location 属性）接下来多行也是首部内容
空白行：一个空行分隔首部和内容主体
响应体：（静态文件，静态指令，动态资源运行结果）最后是响应的内容主体

##### HTTP 状态码
| 1XX | Informational（信息性状态码） | 接收的请求正在处理 |
| --- | --- | --- |
| 2XX | Success（成功状态码） | 请求正常处理完毕 |
| 3XX | Redirection（重定向状态码） | 需要进行附加操作以完成请求 |
| 4XX | Client Error（客户端错误状态码） | 服务器无法处理请求 |
| 5XX | Server Error（服务器错误状态码） | 服务器处理请求出错 |


1XX 信息

- 100 ：本次返回的资源文件并不是一个独立的资源文件，需要浏览器在接收响应包之后，继续向 Http 服务器所要依赖的其他资源文件

2XX 成功

- **200 OK**
- **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
- **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

3XX 重定向

- **301 Moved Permanently** ：永久性重定向
- **302 Found** ：临时性重定向
- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

4XX 客户端错误

- **400 Bad Request** ：请求报文中存在语法错误。
- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- **403 Forbidden** ：请求被拒绝。
- 404：在服务端没有定位到被访问的资源文件，因此无法提供帮助
- 405：已经定位到被访问的资源文件，但是这个 Servlet 对于浏览器采用的请求方式不能处理

5XX 服务器错误

- **500 Internal Server Error** ：服务器正在执行请求时发生错误。
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

2XX 成功

· 200 OK，表示从客户端发来的请求在服务器端被正确处理

· 204 No content，表示请求成功，但响应报文不含实体的主体部分

· 206 Partial Content，进行范围请求

3XX 重定向

· 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL

· 302 found，临时性重定向，表示资源临时被分配了新的 URL

· 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源

· 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况

· 307 temporary redirect，临时重定向，和 302 含义相同

4XX 客户端错误

· 400 bad request，请求报文存在语法错误

· 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息

· 403 forbidden，表示对请求资源的访问被服务器拒绝

· 404 not found，表示在服务器上没有找到请求的资源

5XX 服务器错误

· 500 internal sever error，表示服务器端在执行请求时发生了错误

· 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

##### 短连接，长连接，流水线

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

##### Cookie，Session

Cookie 一般用来保存用户信息

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

Session 的主要作用就是通过服务端记录用户的状态

Cookie 与 Session 选择

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。

存储位置

##### HTTP 和 HTTPS

端口：80，443
安全：SSL/TLS 加密
资源消耗
证书费用

##### HTTP 1.0，HTTP 1.1，HTTP 2.0

1. **长连接** : 在 HTTP/1.0 默认使用的是短连接，HTTP 1.1 默认使用长连接（有非流水线方式和流水线方式）
2. **错误状态响应码** :在 HTTP1.1 中新增了 24 个错误状态响应码
3. **缓存处理**：HTTP1.1 则引入了更多的缓存控制策略
4. **带宽优化及网络连接的使用**
HTTP1.0 中，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，且不支持断点续传功能，
HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，

HTTP 2.0

将报文分成 HEADERS 帧和 DATA 帧

在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。

HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。

HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。
HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。

##### GET，POST

[get，post](https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md)；

# 操作系统

##### 进程通信

1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
2. **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)** 。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
4. **消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。**
5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
7. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

##### 线程同步

1. **互斥量(Mutex)** ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
3. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

##### 进程调度

批处理系统：先到先服务，短作业优先，最短剩余时间优先
交互式系统：时间片轮转，多级反馈队列，优先级

##### 虚拟内存，寻址

##### 页面置换算法

最佳
先进先出
最近最久未使用（在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。）
最近未使用（时钟）（单状态位：使用，双状态位：使用 + 修改）
双状态位：每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。（优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0））

##### ？？？分页，分段（参考书）

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
- 地址空间的维度：分页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

##### 磁盘调度

先来先服务
最短寻道时间优先
扫描（电梯）：保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。（LOOK：不到达最边上，无请求就返回）
循环扫描：单向的扫描算法（C-LOOK：不到达最边上，无请求就返回）
